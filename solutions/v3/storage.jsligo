#import "errors.jsligo" "Errors"
#import "action.jsligo" "Action"

type round_value = 
    ["Waiting"] | ["Played", chest] | ["Revealed", Action.t];


type round = {
    player1 : [round_value,tez],
    player2 : [round_value,tez]
};

export type t = {
    round   : nat,
    player1 : address,
    player2 : address,
    rounds  : map<nat, round>
};

const fresh_round : round = ({ 
    player1 : [Waiting (), 0 as tez],
    player2 : [Waiting (), 0 as tez]
});


const is_waiting = (r:round_value) : bool => {
    match(r, {
        Waiting: () => true,
        Played: _p => false,
        Revealed: _p => false,
    })
};

const is_played = (r:round_value) : bool => {
    match(r, {
        Waiting: () => false,
        Played: _p => true,
        Revealed: _p => false,
    })
};

const is_revealed = (r:round_value) : bool => {
    match(r, {
        Waiting: () => false,
        Played: _p => false,
        Revealed: _p => true,
    })
};

const revealed = (r:round_value) : option<Action.t> => {
    match(r, {
        Waiting: () => None (),
        Played: _p => None (),
        Revealed: p => Some (p),
    })
};

export const fresh_game = (p1:address, p2:address) : t => ({
    round   : 0 as nat,
    player1 : p1,
    player2 : p2,
    rounds  : Map.literal(list([ [0 as nat, fresh_round] ]))
});

export const new_game = (storage:t) : t => {
    const new_round = storage.round + (1 as nat);
    return { 
        ...storage,
        round : new_round,
        rounds : Map.update(new_round, Some(fresh_round), storage.rounds),
    }
};
  
const decode_chest = ([player_key, user_chest, player_secret]: [chest_key, chest, nat]): bytes => {
    return match (Tezos.open_chest(player_key, user_chest, player_secret), {
        Ok_opening: (b: bytes) => b,
        Fail_timelock: () => failwith(Errors.failed_to_open_chest),
        Fail_decrypt: () => failwith(Errors.failed_to_open_chest)
    });
};

const decode_action = (payload: bytes): Action.t => { 
    return match ((Bytes.unpack(payload) as option<Action.t>), {
        None: () => failwith(Errors.failed_to_unpack_payload),
        Some: (x: action) => x,
    });
};

const play_round = ([chest, round_value]:[chest, round_value]) : round_value => {
    return match(round_value, {
        Waiting: () => Played(chest),
        Played: (chest:chest) => failwith(Errors.user_already_played),
        Revealed : (_:action) => failwith(Errors.user_already_revealed),
    });
};

const reveal_round = ([chest_key, secret, round_value]:[chest_key, nat, round_value]) : round_value => {
    return match(round_value, {
        Waiting: () => failwith(Errors.missing_sender_chest),
        Played: (chest:chest) => Revealed(decode_action(decode_chest(chest_key, chest, secret))),
        Revealed : (_:action) => failwith(Errors.user_already_revealed),
    });
};

export const play = ([storage, player, action]:[t, address, chest]) : [list<operation>, t] => {
    if (Tezos.amount == (0 as tez)) {
        failwith(Errors.bet_mount_required);
    }

    const new_round : round = match(Map.find_opt(storage.round, storage.rounds), {
        None: () => failwith(Errors.invalid_round),
        Some: (r:round) => {
            if (storage.player1 == player) {
                return { ...r, player1: [play_round(action, r.player1[0]), Tezos.amount] };
            } else if (storage.player2 == player) {
                return { ...r, player2: [play_round(action, r.player2[0]), Tezos.amount] };
            } else {
                return (failwith(Errors.user_not_allowed_to_play_or_reveal));
            };
        }
    });

    const rounds = Map.update(storage.round, Some(new_round), storage.rounds);

    return [list([]) as list<operation>, { ...storage, rounds: rounds }];    
};

export const reveal = ([storage, player, chest_key, secret]:[t, address, chest_key, nat]) : t => {
    const can_reveal = (round:round) : bool => {
        if (is_waiting(round.player1[0]) || is_waiting(round.player2[0])) {
            return false;
        } else {
            return true;
        }
    };

    const new_round : round = match(Map.find_opt(storage.round, storage.rounds), {
        None: () => failwith(Errors.invalid_round),
        Some: (r:round) => {
            if (can_reveal(r) == false) {
                return (failwith(Errors.user_not_allowed_to_reveal));
            } else if (storage.player1 == player) {
                return { ...r, player1: [reveal_round(chest_key, secret, r.player1[0]), r.player1[1]] };
            } else if (storage.player2 == player) {
                return { ...r, player2: [reveal_round(chest_key, secret, r.player2[0]), r.player2[1]] };
            } else {
                return (failwith(Errors.user_not_allowed_to_play_or_reveal));
            };
        }
    });

    const rounds = Map.update(storage.round, Some(new_round), storage.rounds);

    return { ...storage, rounds: rounds };    
};

export const conclude = (storage:t): [list<operation>,t] => {
    match(Map.find_opt(storage.round, storage.rounds), {
        None: () => failwith(Errors.invalid_round),
        Some: r => {
            const player1 = r.player1;
            const player2 = r.player2;

            match(revealed(player1[0]), {
                None: () => [ list([]) as list<operation>, storage ],
                Some: a1 => {
                    match(revealed(player2[0]), {
                        None: () => [list([]) as list<operation>, storage],
                        Some: a2 => {
                            if (Action.win_against(a1, a2)) {
                                return [
                                    list([
                                        Tezos.transaction(unit, player1[1] + player2[1], Tezos.get_contract(storage.player1) as contract<unit>)
                                    ]), 
                                    new_game(storage)
                                ];
                            } else if (Action.win_against(a2, a1)) {
                                return [
                                    list([
                                        Tezos.transaction(unit, player1[1] + player2[1], Tezos.get_contract(storage.player2) as contract<unit>)
                                    ]),
                                    new_game(storage)
                                ];
                            } else { // Draw
                                return [
                                    list([                                    
                                        Tezos.transaction(unit, player1[1], Tezos.get_contract(storage.player1) as contract<unit>),
                                        Tezos.transaction(unit, player2[1], Tezos.get_contract(storage.player2) as contract<unit>)
                                    ]),
                                    new_game(storage)
                                ];
                            }
                        }
                    })
                }
            });
        }
    });
}
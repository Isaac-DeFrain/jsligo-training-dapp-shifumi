#import "errors.jsligo" "Errors"
#import "action.jsligo" "Action"
#import "storage.jsligo" "Storage"

const play = ([storage, player, action, amount]:[Storage.t, address, chest, tez]) : [list<operation>, Storage.t] => {
    if (amount != (1 as tez)) {
        failwith(Errors.bet_mount_required);
    };

    const round = Storage.current_round(storage);

    if (Storage.is_player1(storage, player) && Storage.is_waiting(round.player1)) {
        return [list([]) as list<operation>, Storage.update_round(storage, Storage.player1_play(round, action, amount))];
    } else if (Storage.is_player2(storage, player) && Storage.is_waiting(round.player2)) {
        return [list([]) as list<operation>, Storage.update_round(storage, Storage.player2_play(round, action, amount))];
    } else {
        return failwith(Errors.user_not_allowed_to_play);
    };
};

const reveal = ([storage, player, chest_key, secret]:[Storage.t, address, chest_key, nat]) : Storage.t => {
    const round = Storage.current_round(storage);

    if (Storage.is_waiting(round.player1) || Storage.is_waiting(round.player2)) {
        return (failwith(Errors.user_not_allowed_to_reveal));
    } else if (Storage.is_player1(storage, player) && Storage.is_played(round.player1)) {
        return Storage.update_round(storage, Storage.player1_reveal(round, chest_key, secret));
    } else if (Storage.is_player2(storage, player) && Storage.is_played(round.player2)) {
        return Storage.update_round(storage, Storage.player2_reveal(round, chest_key, secret));
    } else {
        return failwith(Errors.user_not_allowed_to_reveal);
    };
};

const conclude = (storage:Storage.t): [list<operation>,Storage.t] => {
    const round = Storage.current_round(storage);

    const player1 = round.player1;
    const player2 = round.player2;

    match(Storage.revealed(player1,player2), {
        None: () => 
            [ list([]) as list<operation>, storage ],
        Some: actions => {
            if (Action.win_against(actions.player1[0], actions.player2[0])) {
                return [
                    list([
                        Tezos.transaction(unit, actions.player1[1] + actions.player2[1], Tezos.get_contract(storage.player1) as contract<unit>)
                    ]),
                    Storage.new_game(storage)
                ];
            };
            
            if (Action.win_against(actions.player2[0], actions.player1[0])) {
                return [
                    list([
                        Tezos.transaction(unit, actions.player1[1] + actions.player2[1], Tezos.get_contract(storage.player2) as contract<unit>)
                    ]),
                    Storage.new_game(storage)
                ];
            };
            
            // Draw
            return [
                list([                                    
                    Tezos.transaction(unit, actions.player1[1], Tezos.get_contract(storage.player1) as contract<unit>),
                    Tezos.transaction(unit, actions.player2[1], Tezos.get_contract(storage.player2) as contract<unit>)
                ]),
                Storage.new_game(storage)
            ];
        }
    });
};

export type parameter = ["Play", chest] | ["Reveal", chest_key, nat];

export const main = (parameter: parameter, storage: Storage.t) : [list<operation>, Storage.t] => {
    return match(parameter, {
        Play   : p => play(storage, Tezos.sender, p, Tezos.amount),
        Reveal : p => conclude(reveal(storage, Tezos.sender, p[0], p[1])),
    });
};

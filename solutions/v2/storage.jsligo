#import "errors.jsligo" "Errors"
#import "action.jsligo" "Action"

type round_value = 
    ["Waiting"] | ["Played", chest] | ["Revealed", Action.t];


export type round = {
    player1 : round_value,
    player2 : round_value
};

export type t = {
    round   : nat,
    player1 : address,
    player2 : address,
    rounds  : map<nat, round>
};

const fresh_round : round = ({ 
    player1 : Waiting (),
    player2 : Waiting (),
});

const is_waiting = (r:round_value) : bool => {
    match(r, {
        Waiting: () => true,
        Played: _p => false,
        Revealed: _p => false,
    })
};

const is_played = (r:round_value) : bool => {
    match(r, {
        Waiting: () => false,
        Played: _p => true,
        Revealed: _p => false,
    })
};

const is_revealed = (r:round_value) : bool => {
    match(r, {
        Waiting: () => false,
        Played: _p => false,
        Revealed: _p => true,
    })
};

export const fresh_game = (p1:address, p2:address) : t => ({
    round   : 0 as nat,
    player1 : p1,
    player2 : p2,
    rounds  : Map.literal(list([ [0 as nat, fresh_round] ]))
});

export const is_player1 = (storage:t, player:address) : bool => 
    (storage.player1 == player);

export const is_player2 = (storage:t, player:address) : bool => 
    (storage.player2 == player);

export const new_game = (storage:t) : t => {
    const new_round = storage.round + (1 as nat);
    return { 
        ...storage,
        round : new_round,
        rounds : Map.update(new_round, Some(fresh_round), storage.rounds),
    }
};
  
const decode_chest = ([player_key, user_chest, player_secret]: [chest_key, chest, nat]): bytes => {
    return match (Tezos.open_chest(player_key, user_chest, player_secret), {
        Ok_opening: (b: bytes) => b,
        Fail_timelock: () => failwith(Errors.failed_to_open_chest),
        Fail_decrypt: () => failwith(Errors.failed_to_open_chest)
    });
};

const decode_action = (payload: bytes): Action.t => { 
    return match ((Bytes.unpack(payload) as option<Action.t>), {
        None: () => failwith(Errors.failed_to_unpack_payload),
        Some: (x: action) => x,
    });
};

const play_round = ([chest, round_value]:[chest, round_value]) : round_value => {
    return match(round_value, {
        Waiting: () => Played(chest),
        Played: p => Played(chest),
        Revealed : p => Revealed(p)
    });
};

const reveal_round = ([chest_key, secret, round_value]:[chest_key, nat, round_value]) : round_value => {
    return match(round_value, {
        Waiting: () => Waiting(),
        Played: p => Revealed (decode_action(decode_chest(chest_key, p, secret))),
        Revealed : p => Revealed (p)
    });
};

export const current_round = (storage: t) : round => {
    return match(Map.find_opt(storage.round, storage.rounds), {
        None: () => failwith(Errors.invalid_round),
        Some: r  => r
    });
};

export const player1_play = (round:round, action:chest) : round => {
    return { ...round, player1: play_round(action, round.player1) };
};

export const player2_play = (round:round, action:chest) : round => {
    return { ...round, player2: play_round(action, round.player2) };
};

export const player1_reveal = (round:round, chest_key:chest_key, secret:nat) : round => {
    return { ...round, player1: reveal_round(chest_key, secret, round.player1) };
};

export const player2_reveal = (round:round, chest_key:chest_key, secret:nat) : round => {
    return { ...round, player2: reveal_round(chest_key, secret, round.player2) };
};

export const modify_round = (storage: t, round: round): t => {
    const rounds = Map.update(storage.round, Some(round), storage.rounds);
    return { ...storage, rounds: rounds };    
};
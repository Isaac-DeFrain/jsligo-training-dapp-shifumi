#import "errors.jsligo" "Errors"
#import "action.jsligo" "Action"

type round_value = 
    ["Waiting"] | ["Played", Action.t];

const is_waiting = (r:round_value) : bool => {
    return match(r, {
        Waiting: () => true,
        Played: _p => false
    });
};

const is_played = (r:round_value) : bool => {
    return match(r, {
        Waiting: () => false,
        Played: _p => true,
    });
};

export type round = {
    player1 : round_value,
    player2 : round_value
};

export type t = {
    round : nat,
    player1 : address,
    player2 : address,
    rounds : map<nat, round>,
};

export const fresh_round : round = ({
    player1: Waiting (),
    player2: Waiting ()
});

export const fresh_game = (p1:address, p2:address) : t => {
    return ({ 
        round   : 0 as nat,
        player1 : p1,
        player2 : p2,
        rounds  : Map.literal(list([ [0 as nat, fresh_round] ]))
    });
};

const new_game = (storage:t) : t => {
    const new_round = storage.round + (1 as nat);
    return ({ 
        ...storage,
        round : new_round,
        rounds : Map.update(new_round, Some(fresh_round), storage.rounds)
    });
};
  
export const play_round = (action:Action.t,round_value:round_value) : round_value => {
    return match(round_value, {
        Waiting: () => Played(action),
        Played: _p => failwith(Errors.user_already_played),
    });
};

#import "errors.jsligo" "Errors"
#import "action.jsligo" "Action"

type round_value = ["Waiting"] | ["Played", Action.t];

const is_waiting = (r:round_value) : bool => {
    return match(r, {
        Waiting: () => true,
        Played: _p => false
    });
};

const is_played = (r:round_value) : bool => {
    return match(r, {
        Waiting: () => false,
        Played: _p => true,
    });
};

export type round = {
    player1 : round_value,
    player2 : round_value
};

export type t = {
    round : nat,
    player1 : address,
    player2 : address,
    rounds : map<nat, round>,
};

export const fresh_round : round = ({
    player1: Waiting (),
    player2: Waiting ()
});

export const fresh_game = (p1:address, p2:address) : t => {
    return ({ 
        round   : 0 as nat,
        player1 : p1,
        player2 : p2,
        rounds  : Map.literal(list([ [0 as nat, fresh_round] ]))
    });
};

export const is_player1 = (storage:t, player:address) : bool => 
    (storage.player1 == player);

export const is_player2 = (storage:t, player:address) : bool => 
    (storage.player2 == player);

const new_game = (storage:t) : t => {
    const new_round = storage.round + (1 as nat);
    return ({ 
        ...storage,
        round : new_round,
        rounds : Map.update(new_round, Some(fresh_round), storage.rounds)
    });
};
  
export const play_round = (action:Action.t, round_value:round_value) : round_value => {
    return match(round_value, {
        Waiting: () => Played(action),
        Played: p => Played(p)
    });
};

export const current_round = (storage: t) : round => {
    return match(Map.find_opt(storage.round, storage.rounds), {
        None: () => failwith(Errors.invalid_round),
        Some: r  => r
    });
};

export const round_value_player1 = (round: round) : round_value => {
    return round.player1;
};

export const round_value_player2 = (round: round) : round_value => {
    return round.player2;
};

export const player1_play = (round:round, action:Action.t) : round => {
    return { ...round, player1: play_round(action, round.player1) };
};

export const player2_play = (round:round, action:Action.t) : round => {
    return { ...round, player2: play_round(action, round.player2) };
};

export const update_round = (storage: t, round: round): t => {
    const rounds = Map.update(storage.round, Some(round), storage.rounds);
    return { ...storage, rounds: rounds };    
};